\documentclass[male,czech]{kithesis}

\usepackage{graphics}
\usepackage{array}

% zde nastavte základní informace o bakalářské práci
\newcommand{\AUTOR}{Oleg Musijenko}
\newcommand{\TITULcz}{Tacit programming - návrh doménově specifického jazyka a implementace jeho interpretu} % titul v českém jazyce
\newcommand{\TITULen}{Tacit programming - design of a domain specific language and implementation of it's interpreter} % titul v anglickém jazyce
\newcommand{\KLICOVASLOVAcz}{bakalářská práce, odborný text, programování} % klíčová slova v českém jazyce
\newcommand{\KLICOVASLOVAen}{bachelor thesis} % klíčová slova v anglickém jazyce
\newcommand{\VEDOUCI}{Mgr. Jiří Fišer, Ph.D.}    

\newcommand{\PROGRAM}{Aplikovaná informatika}    
\newcommand{\OBOR}{Informační systémy}    

% nastavení fontů (liší se podle TeXovského stroje)
\iftutex
\usepackage{fontspec}
\setmainfont{Libertinus Serif} % použito je opensource písmo Libertinus, lze použít jakékoliv jiné rozumné
\setsansfont{Libertinus Sans}
\setmonofont[Scale = MatchLowercase]{Libertinus Mono}
\usepackage{unicode-math}  
% písmo pro matematiku, vhodná písma viz  	např. https://developer.mozilla.org/en-US/docs/Mozilla/MathML_Project/Fonts
\setmathfont{Libertinus Math}
\else
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{libertinus}

\usepackage{amsmath,amssymb}
\usepackage{libertinust1math}
\usepackage{graphicx}
\usepackage[font=small, labelfont=bf]{caption}
\fi

\usepackage[style=authoryear,backend=biber,citestyle=nature]{biblatex}
\usepackage{minted}
\usepackage{listings}

\addbibresource{bibliografie.bib}
% vylepšení vzhledu
\usepackage{microtype}
%\sloppy %odpoznámkujte pokud vám často přetékají řádky
\renewcommand{\arraystretch}{1.23} % vertikální roztažení tabulek o 23%
            
% nastavení pro sazbu výpisu kódu
% \usepackage{listings}

\lstset{ %
  language=Haskell,                % hlavní programovací jazyk, seznam podporovaných viz https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
  basicstyle=\ttfamily,    
  showspaces=false,                % show spaces adding particular underscores
  showstringspaces=true,           % underline spaces within strings
  showtabs=false,                  % show tabs within strings adding particular underscores
  frame=single,                    % adds a frame around the code
  tabsize=3,                       % sets default tabsize to 3 spaces
  breaklines=true,                 % sets automatic line breaking
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  keywordstyle=\bfseries,          % keyword style
  commentstyle=\rmfamily,          % comment style
  stringstyle=\itshape,            % string literal style
}

% nastavení hypertextových odkazů a PDF metainformací
\usepackage{url} % přidává příkaz url pro sazbu url
\usepackage[unicode=true,colorlinks=true,
            pdftitle={\TITULcz},pdfauthor={\AUTOR},
            pdfkeywords={\KLICOVASLOVAcz}]{hyperref}
\usepackage[skip=10pt plus1pt]{parskip}
            
\newcommand{\haskellInline}[1]{\colorbox{gray!10}{\mintinline{haskell}{#1}}}

\pagestyle{fancy} % aktivování stylu záhlaví a zápatí z kithesis

%---------------------------------------------------------

\begin{document}
\thispagestyle{empty}
\begin{center}
{\Huge Univerzita Jana Evangelisty Purkyně \\
v~Ústí nad Labem}
\\[16pt]
{\huge Přírodovědecká fakulta}

\vspace{2cm}
\resizebox{8cm}{!}{\includegraphics{LOGO_PRF_CZ_RGB_standard.jpg}}

\vspace{2cm}
{
\huge
\TITULcz\par

\vspace{0.5em}
\LARGE\scshape bakalářská práce
}
\end{center} 
 
\vfill
{
\large
\begin{tabular}{>{\bfseries}rl}
    Vypracoval: 	& \AUTOR\\
    Vedoucí práce: 	& \VEDOUCI\\
&\\
Studijní program:       & \PROGRAM\\
Studijní obor:          & \OBOR\\
\end{tabular} 
}
\vspace{1.5cm}
\begin{center}
\Large\scshape   Ústí nad Labem \the\year
\end{center}

\cleardoublepage
\thispagestyle{empty}

\textbf{\textsf{Cíl bakalářské práce}}

Cílem bakalářské práce je ukázat výhody a nevýhody tacit přístupu k programování. Výstupem práce bude návrh vlastního doménově specifického jazyka (DSL), který
bude využívat tacit programming, a navazující pilotní implementace jeho interpretu.
Návrh jazyka by se měl soustředit na následující body:
• přehledná syntaxe,
• možnosti použití vysokoúrovňových nástrojů pro překlad a podporu běhu programu (např. LLVM v Haskellu) včetně parsování jazyka (např. Parsec v Haskellu),
• efektivita při vykonávaní,
• případná podpora paralelních výpočtů

\cleardoublepage
\thispagestyle{empty}

\textbf{Prohlášení}

Prohlašuji, že jsem tuto bakalářskou práci vypracoval\ifthenelse{\boolean{feminum}}{a}{} samostatně a použil\ifthenelse{\boolean{feminum}}{a}{}
jen pramenů, které cituji a uvádím v přiloženém seznamu literatury.

\vspace{1em}
Byl\ifthenelse{\boolean{feminum}}{a}{} jsem seznámen\ifthenelse{\boolean{feminum}}{a}{} s tím, že se na moji práci vztahují práva a povinnosti vyplývající ze zákona č. 121/2000 Sb., ve znění zákona č. 81/2005 Sb., autorský zákon, zejména se skutečností, že Univerzita Jana Evangelisty Purkyně v Ústí nad Labem má právo na uzavření licenční smlouvy o užití této práce jako školního díla podle § 60 odst. 1 autorského zákona,s tím, že pokud dojde k užití této práce mnou nebo bude poskytnuta licence o užití jinému
subjektu, je Univerzita Jana Evangelisty Purkyně v Ústí nad Labem oprávněna ode mne požadovat přiměřený příspěvek na úhradu nákladů, které na vytvoření díla vynaložila, a to podle okolností až do jejich skutečné výše.

\vspace{1em}
V Ústí nad Labem dne \today \hspace{0.3\textwidth} Podpis:


\clearpage
\thispagestyle{empty}
~\vfill

\begin{flushright}
  Děkuji vedoucímu práce Mgr. Jiřímu Fišerovi, Ph.D.\\ za neocenitelné rady a pomoc při tvorbě bakalářské práce.
\end{flushright}

\cleardoublepage
\thispagestyle{empty}

\textbf{\textsf{Abstrakt}}

\textsc{\TITULcz}

Abstrakt shrnuje základní motivaci práce (kontext), hlavní cíl a následně jednotlivé
autorské kroky k~jeho splnění (co bylo uděláno od úvodních rešerší, přes návrh, implementaci k případnému nasazení. Minimální rozsah je 800 znaků (maximální půl strany).

\textbf{\textsf{Klíčová slova}}

seznam klíčových slov (obecných termínů vystihujících téma práce) v počtu dva až deset 

\vspace{1em}
\hrulefill
\vspace{1em}

\textbf{\textsf{Abstract}}

\textsc{\TITULen}

Translation of Czech abstract.

\textbf{\textsf{Key words}}

Translation of czech key words.

\tableofcontents

\addchap{Úvod}

Tohle potřebuju kurva přepsat, protože to nedává hlavu ani patu. Kurňa, tohle nedává vůbec nic, jen to jen píčovina.

Existují různá programovací paradigma s kterými se může softwarový inženýr setkat. Mezi nejznámější 
paradigma patří strukturované, kde počátek tohoto paradigmatu se datuje v 1967 s Dijkstrovo článkem 
"Goto statement considered harmful". Dijkstra díky 'goto' výrazům nemohl určit správnost programu, proto 
se 'goto' nahradil za struktury typu 'if else', 'while', atd... Poté se můžeme setkat s objektově orientovaným
paradigmatem, který je v dnešní době využíván od menších aplikací až po enterprise systémy. Toto paradigma
dává programátorům možnosti využití polymorfismu, není zapotřebí využívát ukazatele na funkce a pomocí dnešních
nástrojů je jednodušší se zorientovat v zdrojovém kódu. Jako finální paradigma je zde funkcionální. Funkcionální jazyky
omezují primárně omezují mutaci existujících proměnných a zároveň se zaměřují na kompozici funkcí.
Existují samozřejmě i další paradigmata, ale mnohdy je na ně pohlíženo jako na kuriozity. Třeba 
mezi takové patří deklarativní jazyk Prolog, který ověřuje pravdivost výroku v závislosti na předchozích
relací.

Hlavně se budeme zaměřovat na tacit - "beztečkové" paradigma. Do tohoto paradigmatu spadá 
jazyky APL rodiny. Ukážeme si, že i jazyky, které nebyly navržené jako "beztečkové" umožňují v tomto stylu psát.

Tato bakalářská práce předpokládá, že čtenář zná základy funkcionálních jazyků a obzvlášť Haskellu, 
protože návrh je vytvořen v Haskellu pomocí knihoven Parsec a LLVM.

\chapter{Tacit programming}
\textbf{Tacit programming} je programovací styl, 
který klade důraz na skládání a řetězení funkcí a není založen na explicitní specifikaci parametrů funkcí.
Základní principy funkcionálního a taci programování jsou v jazyce JavaScript, 
jelikož se jedná o jeden z nejvíce populárních programovacích jazyků a v zíkladě má funkcionální možnosti. 
Detailnější principy jsou psány v Haskellu.
\begin{minted}{js}
  fetch("APIURL")
  .then(x => fancyFunction(x))
  .then(x => console.log(x))
  .catch(e => console.error(e))
\end{minted}

Zde se řetězí funkce zpětného volání ("Callbacks").

Tento postup je běžný u JavasSript programátorů, ale bohužel má jednu malou nevýhodu.
Tvoří se zde zbytečná anonymní funkce ("arrow function nebo-li šipková") a pokud bychom prohlubovali čím dál víc 
zásobník volání, mohou nám tyto anonymní funkce zabírat paměť a během debuggingu nám tento styl zápisu "znečišťuje" 
zásobník volání. 

\begin{minted}{js}
  fetch("APIURL")
  .then(fancyFunction)
  .then(console.log)
  .catch(console.error)
\end{minted}

Přepsaná ukázka je logicky ekvivalentní k té předešlé. Zásadní rozdíl je ten, že se nemusí na paměťový zásobník ukládat kontext anonymní funkce 
a explicitně se nepředávají parametry funkce. Tudíž se jedná o \textit{tacit} zápis.

Následující úryvek ukazuje, jak funguje \textbf{currying} a proč souvisí s tacit programováním.
\begin{minted}{js}
const curry = (f) => a => b => f(a,b);
const sayHello = (a, b) = `Hello ${a} from ${b}`;
const applyToFunctionArray = (input,...args) => args.map(a => a(input))
const partiallyAppliedData = ["A", "B", "C"].map(curry(sayHello)); 
// [(b) => "Hello A from ${b}", 
//  (b) => "Hello B from ${b}", 
//  (b) => "Hello C from ${b}"]
const partiallyAppliedData2 = ["A", "B", "C"].map(curry(sayHello)(1)); 
// ["Hello A from 1", 
//  "Hello B from 1", 
//  "Hello C from 1"]
\end{minted}
Curry funkce transfomuje existujícé funkci tak, že máme pro každý argument vlastní vracející funkci. Z 
funkce \textbf{f(a,b,c,d)} vzniká funkce \textbf{f(a)(b)(c)(d)} \cite{Currying}. V čem je toto výhodné?
Například je zde uvedené pole, které se skládá z částečně aplikovaných funkcí. 
Takto může programátor naiterovat odpověď ze serveru do objektu z předchozí ukázky, které je závislé na třeba na uživatelském vstupu. 

Zajímavější část je u \textit{partiallyAppliedData2}. Curryovaná funkce vrací 
funkci, jež očekává vstupní parametr, aby byla vyhodnocena. Tento princip je důležitý
pro lenivé vyhodnocení, který využívá Haskell.

Může zde padnout argument, že v našem případě se curryování nachází pouze pro funkci,
která prijímá dva argumenty. Zde je definice funkce, která převádí jakoukoliv funkci na curryovanou.

\begin{minted}{js}
const curry = (f) => (..args) => args.length >= f.length ? 
  f.apply(this, args) : (...args2) => curry.apply(this, args.concat(args2));
\end{minted}
\section{Principy a odlišnosti od klasického procedurálního paradigmatu}

Procedurální paradigma se zaměřuje na psaní procedurálních instrukcí.
Typickým příkladem tohoto paradigmatu je programovací jazyk C, protože se
jedná o standard, tak v následujících příkladech budu porovnávat jazyk C s jazykem Haskell.
Haskell je primárně funkcionální jazyk, tento jazyk umožňujě psát funkce
v "beztečkovém" stylu. 

Následující příklad sumace:

\textbf{Haskell}
\begin{minted}{Haskell}
sumCustom:: (Traversable t, Num a) => t a -> a
sumCustom = foldr (+) 0
\end{minted}
\pagebreak
\textbf{C}
\begin{minted}{c}
int sum(int* arr, size_t numOfElements)
{
    int acc = 0;
    
    for(int i = 0; i < numOfElements; i++)
    {
        acc += *(arr + i);
    }
    
    return acc;
}
\end{minted}
Na příkladu jde vidět, že beztečkový styl zápisu je opravdu kompaktní. 
V Haskellu není třeba zasahovat do parametrů funkcí.
Tento příklad je založen na podstatě tacit programmingu.
Co se týče algoritmizace, tacit programming je známý pro vytváření 
algoritmických řešení pomocí pouze jednoho řádku kódu. 

Na dalším příkladě si ukážeme fibonnacciho posloupnost.
\textbf{Haskell}
\begin{minted}{Haskell}
-- Haskell je lenivý jazyk a proto je možné vytvořit nekonečnou 
-- fibonnacciho posloupnost a z té si vzít jen potřebný počet čísel 
fibonacci:: Num a => Int -> [a]
fibonacci = (flip take) fibonacciInfinite
  where
    fibonacciInfinite:: Num a => [a]
    fibonacciInfinite = scanl (+) 0 (1:fibonacciInfinite)
\end{minted}

\vfill
\pagebreak

\textbf{C}
\begin{minted}{c}
void fibonacci(int* arr, size_t numOfElements)
{
    if(numOfElements > 0)
    {
      arr[0] = 0;
    }
    if(numOfElements > 1)
    {
      arr[1] = 1;
    }
    for(int i = 2; i < numOfElements; i++)
    {
      arr[i] = arr[i - 1] + arr[i - 2];
    }
}
\end{minted}

Z pohledu imperativního programátora implementace v C je zcela jasná. Funkce přijímá ukazatel na
pole a modifikuje toto pole. Zatímco v Haskellu tato implementace může být matoucí. Funkce scanl je 
velice podobná funkci foldl, jen místo vracení akumulátoru, tak vrací průběžně vypočtené hodnoty.

\section{Rešerše existujících implementací}

\chapter{DSL - principy a využití}
DSL (Domain Specific Language) jsou jazyky, které se zaměřují na specifickou doménu problematiky.
Obecně DSL jazyky jsou mnohem jednodušší než jejich plnohodnotné protějšky. Výhodou je, že 
náročnost učení je mnohem nižší než u GPL (General Purpouse Language). Zároveň při potřebě 
expertů na specializovaný obor, jako jsou například doktoři nebo architekti, tak ti nepotřebují znát detaily 
implementace algoritmů, ale místo toho pokud budou mít přístup rovnou k DSL - výpočet šikmosti stěny budovy,
hodnota cukrů v krvi pacienta, tak mohou plnit svojí práci o mnohem efektivněji. \cite{DomainSpecificLanguages}

Jedním z nejrozšířenejších DSL jazyků je ze světa webu a to \textbf{HTML a CSS}. HTML se zaměřuje na vytvoření rámce pro zobrazení textu,
zatímco CSS se zaměřuje na stylizaci webu pomocí DOM selectorů. Pravdou je, že pro CSS se nenachází žádný 
protocol a proto v různých webových enginech, můžete dostat různé výsledky. Příkladem z praxe je zpracování
fontů.

Též existují jazyky DSL, které jsou specifické pouze pro jednu dannou enterprise aplikaci, kde její implementace
často spočívá na bázi XML nebo podobného formátu jako je např YAML. Zde DSL slouží například pro 
zjednodušení UI nebo business logiky. Třeba pro porovnání \textbf{XAML} pro .NET platformu zjednodušuje logiku, 
stylizuje UI a zároveň zbavuje potřeby tvoření "glue" kódu.

Další jazyk který je velice využíván v hardwarovém prostředí je \textbf{VHDL} nebo \textbf{Verilog}. Tyto DSL jsou zaměřená
na simulaci obvodů pomocí FPGA (hradlových polí). Pro building C/C++ projektů existuje \textbf{makefile}. Jedním ze zajímavějších
DSL je DSL pro "continuous integration and deployment". Různé firmy co nabízejí online repositáře se v tomto budou trochu lišit, ale
většina z nich poskytují jakousi formu automatizace vydání programu do oběhu. Toto poskytují firmy jako je GitHub,
GitLab nebo Azure Dev Ops. Na GitHubu pomocí YAMLu můžete sepsat konfigurační soubor na testování a deployment.

\vfill
\pagebreak
{\centering
\captionof{figure}{Výstřižek z GitHub Actions}
\resizebox{15cm}{!}{\includegraphics{Deployment.PNG}}
}

\chapter{Návrh vlastního DSL}
Pro návrh DSL je hlavní vědět o jakou doménu problematiky se jedná. Zatím neexistuje žádná DSL implementace pro konkurenci či paralelizaci vysokého objemu dat.
Příkladem vysokého počtu dat je vzorek signálu a detailnější zpracování takového vzorku je časově velice náročné. Tato časová náročnost může být vyřešena právě zmíněnou
konkurencí, či paralelizací problému. Toto DSL je pojmenované jako \textbf{Haskallyzer}.
Pro řešení této problematiky byl zvolen Haskell, jelikož se zdá jako nejoptimálnější. Pro rozbor jazyka byly komunitami vytvořené knihovny (Parsec, MegaParse, AttoParsec),
obsahuje mechaniky tacit programmingu, je staticky silně typovaný a díky monádám, řešení okrajových případů je snadné.

Návrh danného jazyka:

\begin{minted}{haskell}
[CompileTime]
{
  let exampleCSV = "example.csv" :
    (a,Int)
    (b,Float)
    (c,String)
}

let exampleConcurrentProcess = exampleCSV | kalmanFilter 
                                          | gaussianFilter 
                                      

let exampleNestedConcurrentProcess = exampleCSV | kalmanFilter | sum
                                                               | product
                                                | gaussianFilter

let exampleGUIMainLoop = mainLoop | calculateMainState -> writeToEventQueue
                                  | gatherEventQueue -> fireEvents
\end{minted}

\section{Vysvětlení gramatiky jazyka}

Celý proces je závislý na \textit{Template Haskell} mechanismu. Díky tomuto mechanismu jsou k dispozici části kompilátoru, které umožní generovat kód dle specifikace.

Vytvoří se funkce \textit{exampleCSV}, která vrací obsah csv souboru. Při procesu kompilace se provádí kontrola, zda v csv souboru existuje dvojice "(a, Int)", kde "a" představuje název sloupce a všechny hodnoty ve sloupci "a" jsou typu "Int".
Díky atributu \textit{CompileTime} je možné vytvořit funkci \textit{exampleCSV} bez nutnosti použití IO monády. Jednou z nevýhod této metody je, že při spuštění programu se zaplní paměť, protože obsah csv souboru je součástí samotného spustitelného programu.
Nicméně, díky tomu není nutné používat IO monádu a obsah csv souboru je k dispozici kdekoliv v programu.

Funkce \textit{exampleConcurrentProcess} vytvoří funkci typu \haskellInline{IO ([a],[b])} a předpokládá, že v programu jsou definované a implementované funkce
\haskellInline{kalmanFilter:: CSV -> [a]} a \\
\haskellInline{gaussianFilter:: CSV -> [a]}. Výsledné IO monádě se nejde vyhnout, jelikož se jedná o konkurentní proces, kde vznikají vlákna v jež jsou provedeny výpočty. 

Pro vytvoření konkurentního výpočtu je zapotřebí využít \textit{concurrent pipe compostion}
\haskellInline{ | } operátoru. Každý další \textit{pipe operátor} vytváří dálší vlákno na kterém je prováděný výpočet.
Celá syntaxe je závislá na odsazení, tudíž všechny \textit{pipe operátory} musí mít stejné odsazení.

Příklad s funkcí \haskellInline{let exampleNestedConcurrentProcess} ukazuje, že \textit{pipe operátory} se dají vnořovat.
To znamená, že funkce sum i product musí mít typ
\haskellInline{sum:: (Num a, Num b) => [a] -> b}. Výsledná funkce bude vygenerováná jako typ \\
\haskellInline{exampleConcurrentProcess:: (Num a, Num b) => IO((a,b), [c])}.

Poslední příklad s \haskellInline{let exampleGUIMainLoop} poukazuje, že není potřeba využít toto DSL pouze pro analýzu dat, ale
i pro definování kritických business části programu. Nedílnou součástí GUI aplikací je \textit{EventQueue}, kde
se zaznamenávají všechny interakce uživatele a program může s těmito interakcemi pracovat.

% \begin{minted}{hs}
% [CompileTime]
% {
%   let exampleCSV = "example.csv" :
%     (a,Int)
%     (b,Float)
%     (c,String)
% }
% \end{minted}

\chapter{Implementace interpretu navrženého DSL}

Prvopočáteční implementace zahrnovala převedení jazyka 

\chapter{Ověření použitelnosti (testování funkčnosti, praktické příklady využití)}

Čím více kódu a fíčur v projektu tím obtížnější je definovat, kde se nachází problém a jak se distribujují 
data. Haskallyzer má výhodu oproti konvenčnímu psaní kódu tu, že ty nejkritičtější části kódu jsou sepsány mimo 
business řešení a nabízí šírší pohled na \textit{dataflow}.



\chapter{Závěr}

\chapter{Citace}


\cite{Katuscakc}
\cite{IntroToLLVM}
\printbibliography


\appendix




\end{document}