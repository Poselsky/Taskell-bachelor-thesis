\documentclass[male,czech]{kithesis}

\usepackage{graphics}
\usepackage{array}

% zde nastavte základní informace o bakalářské práci
\newcommand{\AUTOR}{Oleg Musijenko}
\newcommand{\TITULcz}{Tacit programming - návrh doménově specifického jazyka a implementace jeho interpretu} % titul v českém jazyce
\newcommand{\TITULen}{Tacit programming - design of a domain specific language and implementation of it's interpreter} % titul v anglickém jazyce
\newcommand{\KLICOVASLOVAcz}{bakalářská práce, odborný text, programování} % klíčová slova v českém jazyce
\newcommand{\KLICOVASLOVAen}{bachelor thesis} % klíčová slova v anglickém jazyce
\newcommand{\VEDOUCI}{Mgr. Jiří Fišer, Ph.D.}    

\newcommand{\PROGRAM}{Aplikovaná informatika}    
\newcommand{\OBOR}{Informační systémy}    

% nastavení fontů (liší se podle TeXovského stroje)
\iftutex
\usepackage{fontspec}
\setmainfont{Libertinus Serif} % použito je opensource písmo Libertinus, lze použít jakékoliv jiné rozumné
\setsansfont{Libertinus Sans}
\setmonofont[Scale = MatchLowercase]{Libertinus Mono}
\usepackage{unicode-math}  
% písmo pro matematiku, vhodná písma viz  	např. https://developer.mozilla.org/en-US/docs/Mozilla/MathML_Project/Fonts
\setmathfont{Libertinus Math}
\else
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{libertinus}

\usepackage{amsmath,amssymb}
\usepackage{libertinust1math}
\usepackage{graphicx}
\usepackage[font=small, labelfont=bf]{caption}
\fi

\usepackage[style=authoryear,backend=biber,citestyle=nature]{biblatex}
\usepackage{minted}
\usepackage{listings}

\addbibresource{bibliografie.bib}
% vylepšení vzhledu
\usepackage{microtype}
%\sloppy %odpoznámkujte pokud vám často přetékají řádky
\renewcommand{\arraystretch}{1.23} % vertikální roztažení tabulek o 23%
            
% nastavení pro sazbu výpisu kódu
% \usepackage{listings}

\lstset{ %
  language=Haskell,                % hlavní programovací jazyk, seznam podporovaných viz https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
  basicstyle=\ttfamily,    
  showspaces=false,                % show spaces adding particular underscores
  showstringspaces=true,           % underline spaces within strings
  showtabs=false,                  % show tabs within strings adding particular underscores
  frame=single,                    % adds a frame around the code
  tabsize=3,                       % sets default tabsize to 3 spaces
  breaklines=true,                 % sets automatic line breaking
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  keywordstyle=\bfseries,          % keyword style
  commentstyle=\rmfamily,          % comment style
  stringstyle=\itshape,            % string literal style
}

% nastavení hypertextových odkazů a PDF metainformací
\usepackage{url} % přidává příkaz url pro sazbu url
\usepackage[unicode=true,colorlinks=true,
            pdftitle={\TITULcz},pdfauthor={\AUTOR},
            pdfkeywords={\KLICOVASLOVAcz}]{hyperref}
\usepackage[skip=10pt plus1pt]{parskip}
            
\newcommand{\haskellInline}[1]{\colorbox{gray!10}{\mintinline{haskell}{#1}}}

\pagestyle{fancy} % aktivování stylu záhlaví a zápatí z kithesis

%---------------------------------------------------------

\begin{document}
\thispagestyle{empty}
\begin{center}
{\Huge Univerzita Jana Evangelisty Purkyně \\
v~Ústí nad Labem}
\\[16pt]
{\huge Přírodovědecká fakulta}

\vspace{2cm}
\resizebox{8cm}{!}{\includegraphics{LOGO_PRF_CZ_RGB_standard.jpg}}

\vspace{2cm}
{
\huge
\TITULcz\par

\vspace{0.5em}
\LARGE\scshape bakalářská práce
}
\end{center} 
 
\vfill
{
\large
\begin{tabular}{>{\bfseries}rl}
    Vypracoval: 	& \AUTOR\\
    Vedoucí práce: 	& \VEDOUCI\\
&\\
Studijní program:       & \PROGRAM\\
Studijní obor:          & \OBOR\\
\end{tabular} 
}
\vspace{1.5cm}
\begin{center}
\Large\scshape   Ústí nad Labem \the\year
\end{center}

\cleardoublepage
\thispagestyle{empty}

\textbf{\textsf{Cíl bakalářské práce}}

Cílem bakalářské práce je ukázat výhody a nevýhody tacit přístupu k programování. Výstupem práce bude návrh vlastního doménově specifického jazyka (DSL), který
bude využívat tacit programming, a navazující pilotní implementace jeho interpretu.
Návrh jazyka by se měl soustředit na následující body:\\
• přehledná syntaxe,\\
• možnosti použití vysokoúrovňových nástrojů pro překlad a podporu běhu programu (např. LLVM v Haskellu) včetně parsování jazyka (např. Parsec v Haskellu),\\
• efektivita při vykonávaní,\\
• případná podpora paralelních výpočtů

\cleardoublepage
\thispagestyle{empty}

\textbf{Prohlášení}

Prohlašuji, že jsem tuto bakalářskou práci vypracoval\ifthenelse{\boolean{feminum}}{a}{} samostatně a použil\ifthenelse{\boolean{feminum}}{a}{}
jen pramenů, které cituji a uvádím v přiloženém seznamu literatury.

\vspace{1em}
Byl\ifthenelse{\boolean{feminum}}{a}{} jsem seznámen\ifthenelse{\boolean{feminum}}{a}{} s tím, že se na moji práci vztahují práva a povinnosti vyplývající ze zákona č. 121/2000 Sb., ve znění zákona č. 81/2005 Sb., autorský zákon, zejména se skutečností, že Univerzita Jana Evangelisty Purkyně v Ústí nad Labem má právo na uzavření licenční smlouvy o užití této práce jako školního díla podle § 60 odst. 1 autorského zákona,s tím, že pokud dojde k užití této práce mnou nebo bude poskytnuta licence o užití jinému
subjektu, je Univerzita Jana Evangelisty Purkyně v Ústí nad Labem oprávněna ode mne požadovat přiměřený příspěvek na úhradu nákladů, které na vytvoření díla vynaložila, a to podle okolností až do jejich skutečné výše.

\vspace{1em}
V Ústí nad Labem dne \today \hspace{0.3\textwidth} Podpis:


\clearpage
\thispagestyle{empty}
~\vfill

\begin{flushright}
  Děkuji vedoucímu práce Mgr. Jiřímu Fišerovi, Ph.D.\\ za neocenitelné rady a pomoc při tvorbě bakalářské práce.
\end{flushright}

\cleardoublepage
\thispagestyle{empty}

\textbf{\textsf{Abstrakt}}

\textsc{\TITULcz}

% Abstrakt shrnuje základní motivaci práce (kontext), hlavní cíl a následně jednotlivé
% autorské kroky k~jeho splnění (co bylo uděláno od úvodních rešerší, přes návrh, implementaci k případnému nasazení. Minimální rozsah je 800 znaků (maximální půl strany).

\textbf{\textsf{Klíčová slova}}

% seznam klíčových slov (obecných termínů vystihujících téma práce) v počtu dva až deset 

\vspace{1em}
\hrulefill
\vspace{1em}

\textbf{\textsf{Abstract}}

\textsc{\TITULen}

Translation of Czech abstract.

\textbf{\textsf{Key words}}

Translation of czech key words.

\tableofcontents

\addchap{Úvod}

Programovací paradigma je způsob myšlení a přístupu k návrhu, 
strukturování a implementaci počítačových programů. 
Definuje sadu pravidel, postupů, technik a konceptů, které určují způsob,
jakým se programy píší a organizují. Paradigma poskytuje rámec pro definici a 
řešení problémů v programování.

Některé z nejznámějších programovacích paradigmat zahrnují:

\section{Procedurální paradigma}
Zaměřuje se na sekvenci instrukcí, 
které jsou vykonávány postupně. 
Program je rozdělen na procedury a funkce, které provádějí určité operace. Příkladem takového 
paradigmatu je jazyk C, GOlang a Assembly. Zde se programátoři často setkávají s nutností
manuální správou paměti (\textit{malloc}, \textit{free}).

\section{Objektově orientované paradigma - OOP}
Klade důraz na objekty a jejich interakce. 
Program je strukturován kolem tříd, které obsahují data (atributy) a metody (funkce), 
které s těmito daty pracují. Toto paradigma je obohaceno o \textbf{polymorfismus}.
Vývojáři si mohou OOP představit jako nadmonžinu Procedurálního paradigmatu.

V závislosti na programovacím jazyce, 
vývojáři mohou vužívat automatickou správu paměti díky \textit{garbage collectoru}, kde 
tuto správu paměti vužívají C\# a Java. Pokud je zapotřebí manuální správa paměti, je zde
C\+\+ nebo Rust. Rust je zajímavý tím, že využívá \textit{borrow checker} a má napodobit
chování smart pointerů.


\section{Funkcionální paradigma - FP}
Jedná se o deklarativní způsob programování, kde funkce jsou 
považovány za základní stavební bloky programu. 
Funkcionální jazyky mají za cíl minimalizovat mutaci dat a preferovat neměnné \textit{immutable}
struktury. 
To přispívá ke stabilitě, zjednodušené paralelizaci a eliminaci některých typů chyb. 
Jazyky jako Lisp a jeho dialekty, oCaml, Closure, F\# a Haskell 
jsou běžnými příklady funkcioního programování.

V jednotlivých funkcionálních jazycích je povolena různá míra mutace dat. 
Například jazyk F\# umožňuje mutaci dat kdekoli v programu, což je částečně záměrem, 
aby oslovil uživatele jazyka C\#. Na druhou stranu, 
v jazyce Haskell jsou mutace omezeny v IO monádě a data musí být uloženy 
ve specifických typech jako IORef, STRef nebo MVar. Takto Haskell 
pomáhá udržet jasnou separaci mezi čistým funkcionalním kódem a kódem, 
který se zabývá měnícím se stavem nebo interakcí s okolím.


Je důležité si uvědomit, že míra povolené mutace dat se může lišit mezi jednotlivými funkcionálními jazyky a je závislá na jejich návrhu a filozofii. Každý jazyk si volí kompromis mezi funkcionalitou a striktností v oblasti mutace, aby splňoval požadavky svých uživatelů a cílů, které si klade.

\section{Cíl práce}

Cílem práce je zaměření na \textit{tacit} - "beztečkové" paradigma a implementovat
\textit{Domain Specific Language} s tímto paradigmatem. V práci budou ukázky, jak
tacit programming vypadá a budou vyzdvyženy argumenty proč s tacit programmingem
vůbec pracovat.
Do tohoto paradigmatu spadají jazyky APL rodiny. 
Ukázky v této práci potvrdí, že jazyky které nebyly primárně navržené jako "beztečkové" 
umožňují v tomto stylu psát.

Tato bakalářská práce předpokládá, že čtenář zná základy funkcionálních jazyků a obzvlášť Haskellu, 
protože návrh je vytvořen v Haskellu pomocí knihoven Parsec.

\chapter{Tacit programming}
\textbf{Tacit programming} je programovací styl, 
který klade důraz na skládání a řetězení funkcí a není založen na explicitní specifikaci parametrů funkcí.
Pro základní ukázky bude využit JavaScript jelikož se jedná o jeden z nejpopulárnějších jazyků. 
Základní principy funkcionálního a tacit programování jsou v jazyce JavaScript,
jelikož se jedná o jeden z nejvíce populárních programovacích jazyků a v základu má již funkcionální možnosti.
Detailnější principy jsou psány v Haskellu.
\begin{minted}{js}
  fetch("APIURL")
  .then(x => fancyFunction(x))
  .then(x => console.log(x))
  .catch(e => console.error(e))
\end{minted}

Zde se řetězí funkce zpětného volání ("Callbacks").

Tento postup je běžný u JavasSript programátorů, ale bohužel má jednu malou nevýhodu.
Tvoří se zde zbytečná anonymní funkce ("arrow function nebo-li šipková") a pokud bychom prohlubovali čím dál víc 
zásobník volání, mohou nám tyto anonymní funkce zabírat paměť a během debuggingu nám tento styl zápisu "znečišťuje" 
zásobník volání. 

\begin{minted}{js}
  fetch("APIURL")
  .then(fancyFunction)
  .then(console.log)
  .catch(console.error)
\end{minted}

Přepsaná ukázka je logicky ekvivalentní k té předešlé. Zásadní rozdíl je ten, že se nemusí na paměťový zásobník ukládat kontext anonymní funkce 
a explicitně se nepředávají parametry funkce. Tudíž se jedná o \textit{tacit} zápis.

Následující úryvek ukazuje, jak funguje \textbf{currying} a proč souvisí s tacit programováním.
\begin{minted}{js}
const curry = (f) => a => b => f(a,b);
const sayHello = (a, b) = `Hello ${a} from ${b}`;
const applyToFunctionArray = (input,...args) => args.map(a => a(input))
const partiallyAppliedData = ["A", "B", "C"].map(curry(sayHello)); 
// [(b) => "Hello A from ${b}", 
//  (b) => "Hello B from ${b}", 
//  (b) => "Hello C from ${b}"]
const partiallyAppliedData2 = ["A", "B", "C"].map(curry(sayHello)(1)); 
// ["Hello A from 1", 
//  "Hello B from 1", 
//  "Hello C from 1"]
\end{minted}
Curry funkce transfomuje existujícé funkci tak, že máme pro každý argument vlastní vracející funkci. Z 
funkce \textbf{f(a,b,c,d)} vzniká funkce \textbf{f(a)(b)(c)(d)} \cite{Currying}. V čem je toto výhodné?
Například je zde uvedené pole, které se skládá z částečně aplikovaných funkcí. 
Takto může programátor naiterovat odpověď ze serveru do objektu z předchozí ukázky, které je závislé na třeba na uživatelském vstupu. 

Zajímavější část je u \textit{partiallyAppliedData2}. Curryovaná funkce vrací 
funkci, jež očekává vstupní parametr, aby byla vyhodnocena. Tento princip je důležitý
pro lenivé vyhodnocení, který využívá Haskell.

Může zde padnout argument, že v našem případě se curryování nachází pouze pro funkci,
která prijímá dva argumenty. Zde je definice funkce, která převádí jakoukoliv funkci na curryovanou.

\begin{minted}{js}
const curry = (f) => (..args) => args.length >= f.length ? 
  f.apply(this, args) : (...args2) => curry.apply(this, args.concat(args2));
\end{minted}
\section{Principy a odlišnosti od klasického paradigmatu}

Procedurální paradigma se zaměřuje na psaní procedurálních instrukcí.
Typickým příkladem tohoto paradigmatu je programovací jazyk C, protože se
jedná o standard, tak v následujících příkladech budu porovnávat jazyk C s jazykem Haskell.
Haskell je primárně funkcionální jazyk, tento jazyk umožňujě psát funkce
v "beztečkovém" stylu. 

Následující příklad sumace:

\textbf{Haskell}
\begin{minted}{Haskell}
sumCustom:: (Traversable t, Num a) => t a -> a
sumCustom = foldr (+) 0
\end{minted}
\pagebreak
\textbf{C}
\begin{minted}{c}
int sum(int* arr, size_t numOfElements)
{
    int acc = 0;
    
    for(int i = 0; i < numOfElements; i++)
    {
        acc += *(arr + i);
    }
    
    return acc;
}
\end{minted}
Na příkladu jde vidět, že beztečkový styl zápisu je opravdu kompaktní. 
V Haskellu není třeba zasahovat do parametrů funkcí.
Tento příklad je založen na podstatě tacit programmingu.
Co se týče algoritmizace, tacit programming je známý pro vytváření 
algoritmických řešení pomocí pouze jednoho řádku kódu. 

Na dalším příkladě si ukážeme fibonnacciho posloupnost.
\textbf{Haskell}
\begin{minted}{Haskell}
-- Haskell je lenivý jazyk a proto je možné vytvořit nekonečnou 
-- fibonnacciho posloupnost a z té si vzít jen potřebný počet čísel 
fibonacci:: Num a => Int -> [a]
fibonacci = (flip take) fibonacciInfinite
  where
    fibonacciInfinite:: Num a => [a]
    fibonacciInfinite = scanl (+) 0 (1:fibonacciInfinite)
\end{minted}

\vfill
\pagebreak

\textbf{C}
\begin{minted}{c}
void fibonacci(int* arr, size_t numOfElements)
{
    if(numOfElements > 0)
    {
      arr[0] = 0;
    }
    if(numOfElements > 1)
    {
      arr[1] = 1;
    }
    for(int i = 2; i < numOfElements; i++)
    {
      arr[i] = arr[i - 1] + arr[i - 2];
    }
}
\end{minted}

Z pohledu imperativního programátora implementace v C je zcela jasná. Funkce přijímá ukazatel na
pole a modifikuje toto pole. Zatímco v Haskellu tato implementace může být matoucí. Funkce scanl je 
velice podobná funkci foldl, jen místo vracení akumulátoru, tak vrací průběžně vypočtené hodnoty.

\section{Debugging}

Debugging je zásadní činností při vývoji softwaru, která umožňuje identifikovat, 
analyzovat a odstraňovat chyby ve zdrojovém kódu. 
Proces debuggování je obzvláště důležitý v imperativních a objektově orientovaných jazycích, 
které často disponují vyspělými debugovacími nástroji. 
V těchto jazycích je očekáváno sekvenční vykonávání instrukcí, 
což usnadňuje postupné sledování jejich provádění. 
Inspekce zásobníku volání představuje 
další přirozenou součást debuggingu v těchto jazycích.

V případě lenivého jazyka Haskell však debugging přináší značné obtíže. 
Haskell využívá mechanismu lenivého vyhodnocování, což znamená, 
že hodnoty jsou vypočteny až ve chvíli, kdy jsou skutečně potřeba. 
Tato vlastnost komplikuje proces sledování výpočtu a identifikaci chyb. 
I přes existenci několika debuggovacích nástrojů pro Haskell může 
debugging pro zkušeného vývojáře představovat opravdovou výzvu. 
Zmatek může vznikat zejména při určování, 
kde a jak byla konkrétní proměnná získána, 
neboť její hodnota je vypočítána až v okamžiku, 
kdy je použita.
\pagebreak

Naštěstí Haskell nabízí možnost využití REPL 
(Read - Eval - Print - Loop) prostředí, 
které umožňuje interaktivní evaluaci výrazů a postupné zkoumání jejich chování. 
REPL tak může sloužit jako užitečný nástroj pro rychlé testování 
a experimentování s funkcemi a výrazy. 
Přítomnost REPL v Haskellu zčásti kompenzuje obtíže spojené 
s debuggingem a poskytuje prostředí pro analýzu a ladění kódu.

\section{Rešerše existujících implementací}

\chapter{DSL - principy a využití}
DSL (Domain Specific Language) jsou jazyky, které se zaměřují na specifickou doménu problematiky.
Obecně DSL jazyky jsou mnohem jednodušší než jejich plnohodnotné protějšky. Výhodou je, že 
náročnost učení je mnohem nižší než u GPL (General Purpose Language). Zároveň při potřebě 
expertů na specializovaný obor, nepotřebují znát detaily 
implementace algoritmů, ale místo toho pokud budou mít přístup rovnou k DSL - výpočet šikmosti stěny budovy,
hodnota cukrů v krvi pacienta, tak mohou plnit svojí práci o mnohem efektivněji. \cite{DomainSpecificLanguages}

Jedním z nejrozšířenejších DSL jazyků je ze světa webu a to \textbf{HTML a CSS}. HTML se zaměřuje na vytvoření rámce pro zobrazení textu,
zatímco CSS se zaměřuje na stylizaci webu pomocí DOM selectorů. Pravdou je, že pro CSS se nenachází žádný 
protocol a proto v různých webových enginech, můžete dostat různé výsledky. Příkladem z praxe je zpracování
fontů.

Též existují jazyky DSL, které jsou specifické pouze pro jednu dannou enterprise aplikaci, kde její implementace
často spočívá na bázi XML nebo podobného formátu jako je např YAML. Zde DSL slouží například pro 
zjednodušení UI nebo business logiky. Třeba pro porovnání \textbf{XAML} pro .NET platformu zjednodušuje logiku, 
stylizuje UI a zároveň zbavuje potřeby tvoření "glue" kódu.

Další jazyk který je velice využíván v hardwarovém prostředí je \textbf{VHDL} nebo \textbf{Verilog}. Tyto DSL jsou zaměřená
na simulaci obvodů pomocí FPGA (hradlových polí). Pro kompilaci projektů existuje \textbf{makefile} a je nejčastěji spárován s C/C++. 
Jsou zde DSL pro "continuous integration and deployment". 
Různé firmy co nabízejí online repositáře se v tomto budou trochu lišit, ale
většina z nich poskytují jakousi formu automatizace vydání programu do oběhu. Toto poskytují firmy jako je GitHub,
GitLab nebo Azure Dev Ops. Na GitHubu pomocí YAMLu se dají sepsat konfigurační soubory 
na testování a deployment.

\vfill
\pagebreak
{\centering
\captionof{figure}{Výstřižek z GitHub Actions}
\resizebox{15cm}{!}{\includegraphics{Deployment.PNG}}
}

\chapter{Návrh vlastního DSL}
Pro návrh DSL je hlavní vědět o jakou doménu problematiky se jedná. Zatím neexistuje žádná DSL implementace pro konkurenci či paralelizaci vysokého objemu dat.
Příkladem vysokého počtu dat je vzorek signálu a detailnější zpracování takového vzorku je časově velice náročné. Tato časová náročnost může být vyřešena právě zmíněnou
konkurencí, či paralelizací problému. Toto DSL je pojmenované jako \textbf{Haskallyzer}.
Pro řešení této problematiky byl zvolen Haskell, jelikož se zdá jako nejoptimálnější. Pro rozbor jazyka byly komunitami vytvořené knihovny (Parsec, MegaParse, AttoParsec),
obsahuje mechaniky tacit programmingu, je staticky silně typovaný a díky monádám, řešení okrajových případů je snadné.

Návrh danného jazyka:

\begin{minted}{haskell}
[CompileTime]
{
  let exampleCSV = "example.csv" :
    (a,Int)
    (b,Float)
    (c,String)
}

let exampleConcurrentProcess = exampleCSV | kalmanFilter 
                                          | gaussianFilter 
                                      

let exampleNestedConcurrentProcess = exampleCSV | kalmanFilter | sum
                                                               | product
                                                | gaussianFilter

let exampleGUIMainLoop = mainLoop | calculateMainState -> writeToEventQueue
                                  | gatherEventQueue -> fireEvents
\end{minted}

\section{Vysvětlení gramatiky jazyka}

Celý proces je závislý na \textit{Template Haskell} mechanismu. Díky tomuto mechanismu jsou k dispozici části kompilátoru, které umožní generovat kód dle specifikace.

Vytvoří se funkce \textit{exampleCSV}, která vrací obsah csv souboru. Při procesu kompilace se provádí kontrola, zda v csv souboru existuje dvojice "(a, Int)", kde "a" představuje název sloupce a všechny hodnoty ve sloupci "a" jsou typu "Int".
Díky atributu \textit{CompileTime} je možné vytvořit funkci \textit{exampleCSV} bez nutnosti použití IO monády. Jednou z nevýhod této metody je, že při spuštění programu se zaplní paměť, protože obsah csv souboru je součástí samotného spustitelného programu.
Nicméně díky tomu není nutné používat IO monádu a obsah csv souboru je k dispozici kdekoliv v programu.

Funkce \textit{exampleConcurrentProcess} vytvoří funkci typu \haskellInline{IO ([a],[b])} a předpokládá, že v programu jsou definované a implementované funkce
\haskellInline{kalmanFilter:: CSV -> [a]} a \\
\haskellInline{gaussianFilter:: CSV -> [a]}. Výsledné IO monádě se nejde vyhnout, jelikož se jedná o konkurentní proces, kde vznikají vlákna v jež jsou provedeny výpočty. 

Pro vytvoření konkurentního výpočtu je zapotřebí využít \textit{concurrent pipe compostion}
\haskellInline{ | } operátoru. Každý další \textit{pipe operátor} vytváří dálší vlákno na kterém je prováděný výpočet.
Celá syntaxe je závislá na odsazení, tudíž všechny \textit{pipe operátory} musí mít stejné odsazení.

Příklad s funkcí \haskellInline{let exampleNestedConcurrentProcess} ukazuje, 
že \textit{pipe operátory} se dají vnořovat. To znamená, že funkce sum i product musí mít typ
\haskellInline{sum:: (Num a, Num b) => [a] -> b}. Výsledná funkce bude vygenerováná jako typ \\
\haskellInline{exampleConcurrentProcess:: (Num a, Num b) => IO((a,b), [c])}.

Poslední příklad s \haskellInline{let exampleGUIMainLoop} poukazuje, že není potřeba využít toto DSL pouze pro analýzu dat, ale
i pro definování kritických business části programu. Nedílnou součástí GUI aplikací je \textit{EventQueue}, kde
se zaznamenávají všechny interakce uživatele a program může s těmito interakcemi pracovat.

% \begin{minted}{hs}
% [CompileTime]
% {
%   let exampleCSV = "example.csv" :
%     (a,Int)
%     (b,Float)
%     (c,String)
% }
% \end{minted}

\chapter{Implementace interpretu navrženého DSL}

Návrh jakéhokoliv DSL (a nejen DSL, ale i programovacího jazyka celkově) zahrnuje
\textbf{Lexer, Parser a Abstraktní syntaktický strom}.

\textbf{Lexer} má zaúkol přečíst soubor a najít jednotlivé tokeny v daném souboru.
Tyto tokeny mohou obsahovat metadata, jako jsou řádek a sloupec, kde se token nachází,
jaký token předcházel a jaký následuje atd... Tyto tokeny jsou zpracovány \textbf{parserem}, 
který má zaúkol přečíst tokeny a hledat mezi nimi dle předem definované gramatiky vztahy 
a zpracovat je do abstraktního syntaktického stromu. Abstraktní syntaktický strom je výsledek
parsování a obsahuje všechny definice jazyka.

\section{Implementace pomocí LLVM}

Prvopočáteční implementace zahrnovala využití knihovny LLVM, která 
má za následek převzít AST a převést tento jazyk do LLVM intermediate representation (IR).
Bohužel LLVM se spíše hodí na vytvoření generického programovacího jazyka, než na vytvoření
DSL. DSL se dá touto knihovnou vytvořit, ale pro každou vygenerovanou funkci se musí
vytvořit binding mezi IR, jazykem C a Haskellem. Toto řešení je rozhodně možné, 
ale zvyšuje komplexitu projektu, což je nad rámcem této práce.

\section{Lexer}

\section{Parser}

\section{Abstraktní sysnaktický strom - AST}

\section{Testování}

\chapter{Ověření použitelnosti (testování funkčnosti, praktické příklady využití)}

Abychom si ověřili využití Haskelyzeru, hodil by se nějaký praktický příklad.



\section{Praktické využití}
S rozšiřujícím se kódem a funkcionalitou projektu se zvyšuje obtížnost určení, 
kde se nachází problém a jak jsou data distribuována v daném systému. 
Jednou z nejkomplikovanějších výzev při psaní softwaru je jeho škálovatelnost. 
Haskallyzer má výhodu oproti tradičnímu způsobu psaní kódu v tom, 
že nejkritičtější části kódu jsou odděleny od business řešení a nabízejí širší pohled na tok dat. 
To může být z jedním hlavních argumentů, proč toto DSL využí pro větší projekty,
protože usnadnuje jeho škálování.
Vývojáři mají možnost určit, které části jsou nejdůležitější pro daný cíl a zapsat je do Haskallyzeru.

Konkurence má výhodu v tom, že obecně zvyšuje škálovatelnost softwaru, 
ale zároveň přináší složitější stav a zvyšuje riziko výskytu chyb. 
Haskallyzer není pouze DSL pro vnější zápis kritických částí softwaru, 
ale také umožňuje zápis konkurentních výpočtů v snadno čitelné formě. 
Tím vzniká určitá forma samo-dokumentace, 
kterou lze statickým jazykovým analyzátorem například převést do UML zápisu.


\chapter{Závěr}

\chapter{Citace}


\cite{Katuscakc}
\cite{IntroToLLVM}
\printbibliography


\appendix




\end{document}